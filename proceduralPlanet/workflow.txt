1. Calculate adaptive parameters (voxel size, resolution, LOD distances)
   â””â”€ Based on PlanetRadius

2. Create chunk grid on cube faces
   â””â”€ For each of 6 cube faces:
       â””â”€ Divide face into ChunksPerFace Ã— ChunksPerFace grid
           â””â”€ For each grid cell:
               â””â”€ Calculate UV bounds (UVMin, UVMax) in [-1, +1] space
               â””â”€ Calculate chunk center position
               â””â”€ Spherify the position (cube â†’ sphere)
               â””â”€ Store as FChunkInfo (not yet spawned)

Result: Array of FChunkInfo structs (potential chunks)


Every Frame:
1. Get observer position (camera/viewport)
2. Calculate distance to each chunk
3. Determine if chunk should be:
   - Spawned (if within render distance)
   - LOD level (based on distance)
   - Despawned (if too far)

4. Add chunks to spawn queue
5. Process spawn queue (limited per frame)
   â””â”€ Spawn AVoxelChunk actor
   â””â”€ Set chunk parameters (resolution, voxel size, seed, etc.)
   â””â”€ Call GenerateChunkAsync()


BACKGROUND THREAD:
â”œâ”€ 1. Create DensityConfig
â”‚   â””â”€ Packages all parameters (radius, noise settings, seed, etc.)
â”‚
â”œâ”€ 2. Create PlanetDensityGenerator instance
â”‚   â””â”€ Constructor validates config
â”‚
â”œâ”€ 3. Generate Density Field
â”‚   â””â”€ Call: DensityGen.GenerateDensityField()
â”‚       â””â”€ Returns: GenData (densities + positions arrays)
â”‚
â””â”€ 4. Generate Mesh
    â””â”€ Call: GenerateMeshFromDensity()
        â””â”€ Returns: FChunkMeshData (vertices, triangles, normals)

GAME THREAD:
â””â”€ 5. Apply mesh to ProceduralMeshComponent
    â””â”€ Call: CreateMeshSection()


For each voxel in 3D grid (Resolution+1)Â³:
    â”œâ”€ Calculate 3D grid coordinates (x, y, z)
    â”‚   x, y = horizontal on cube face
    â”‚   z = radial altitude from surface
    â”‚
    â”œâ”€ STEP 1: Get Projected Position
    â”‚   â””â”€ Call: GetProjectedPosition(x, y, z, ...)
    â”‚       â”‚
    â”‚       â”œâ”€ Convert (x, y) to UV percentage [0, 1]
    â”‚       â”œâ”€ Map to chunk's UV bounds [UVMin, UVMax]
    â”‚       â”œâ”€ Create point on unit cube face
    â”‚       â”œâ”€ Spherify (cube â†’ sphere)
    â”‚       â”œâ”€ Calculate altitude from z
    â”‚       â””â”€ Return: SphereDirection Ã— (Radius + Altitude)
    â”‚
    â”œâ”€ STEP 2: Sample Density
    â”‚   â””â”€ Call: SampleDensity(PlanetRelPos)
    â”‚       â”‚
    â”‚       â”œâ”€ A. Sample Sphere Density
    â”‚       â”‚   â””â”€ SampleSphereDensity()
    â”‚       â”‚       â””â”€ Returns: (Radius - Distance) / VoxelSize
    â”‚       â”‚           â€¢ Positive = inside planet
    â”‚       â”‚           â€¢ Negative = outside planet
    â”‚       â”‚
    â”‚       â”œâ”€ B. Sample Noise
    â”‚       â”‚   â””â”€ SampleNoise()
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€ ðŸ”§ FIXED: Project to surface
    â”‚       â”‚       â”‚   â””â”€ SurfacePos = Direction Ã— Radius
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€ Get FBM value
    â”‚       â”‚       â”‚   â””â”€ SampleFBM(SurfacePos)
    â”‚       â”‚       â”‚       â”‚
    â”‚       â”‚       â”‚       â””â”€ For each octave:
    â”‚       â”‚       â”‚           â”œâ”€ Call SimplexNoise()
    â”‚       â”‚       â”‚           â”œâ”€ Add weighted result
    â”‚       â”‚       â”‚           â”œâ”€ Increase frequency
    â”‚       â”‚       â”‚           â””â”€ Decrease amplitude
    â”‚       â”‚       â”‚
    â”‚       â”‚       â””â”€ Scale: FBM Ã— Amplitude / VoxelSize
    â”‚       â”‚
    â”‚       â””â”€ C. Combine: SphereDensity + Noise
    â”‚
    â””â”€ Store: density + position

Result: GenData struct with arrays of densities and positions


For each cube in the density grid (ResolutionÂ³):
    â”œâ”€ Get 8 corner densities
    â”œâ”€ Get 8 corner positions (in Chunk Local Space)
    â”‚   â””â”€ Transform: Planet Local â†’ World â†’ Chunk Local
    â”‚
    â”œâ”€ Determine cube configuration
    â”‚   â””â”€ CubeIndex based on which corners are inside/outside
    â”‚
    â”œâ”€ If cube intersects surface:
    â”‚   â”œâ”€ Interpolate edge vertices
    â”‚   â”‚   â””â”€ VertexInterp() - finds zero-crossing
    â”‚   â”‚
    â”‚   â”œâ”€ Create triangles from lookup table
    â”‚   â”‚
    â”‚   â””â”€ For each vertex:
    â”‚       â”œâ”€ Add vertex position (Chunk Local)
    â”‚       â”œâ”€ Calculate normal
    â”‚       â”‚   â””â”€ Transform: Chunk Local â†’ World â†’ Planet Local
    â”‚       â”‚   â””â”€ GetNormalAtPos() - gradient of density
    â”‚       â”‚   â””â”€ Transform: Planet Local â†’ World â†’ Chunk Local
    â”‚       â””â”€ Add color (for LOD debugging)
    â”‚
    â””â”€ Result: Mesh data (vertices, triangles, normals)

Return to Game Thread for rendering


